/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package datastructures.LinkedList;

import java.util.ArrayList;
import java.util.List;

public class LinkedList {

    Node head; //this is the head of the list

   public Object getHead() {
        return this.head.data;
    }

    public void insert(Object newData) {
        Node newNode = new Node(newData, this.head); //creating the new Node
        newNode.next = head; //assigning the current head to the next node
        head = newNode; //change head to be the newNode added
    }

    public boolean includes(Object data){

        Node current = head;
        while(current != null){
            if(current.data.equals(data)){
                return true;
            }
            current = current.next;
        }

    return false;
    }

    public String toString(){

        List<Object> nodeList = new ArrayList<>();
        Node current = head;
        while(current != null){
            nodeList.add(current.data);
            current = current.next;
            System.out.println("this");
        }
        return String.valueOf(nodeList);

    }

    public void append(Object newData){
        Node newNode = new Node(newData, this.head);

        if(this.head == null){
            this.head = new Node(newData, null);
            return;
        }
        Node last = head;
        while(last.next != null){
            last = last.next;
            last.next = newNode;
        }
    }

    public void insertBefore(Object newData, Object value) {
        if (this.head != null) {
            if (head.data.equals(newData)) ;
            insert(value);
            return;
//            this.head = new Node(newData, null);
        } else {
            Node newNode;
            Node current = head;

            while (current.next != null) {
                if (current.next.data.equals(value)) {
                    current.next = new Node(value, current.next);
                    return;
                }
                current = current.next;
            }

            throw new IllegalArgumentException("Element does not exist");
        }
    }

    public void insertAfter(Object newData, Object value){
        if(this.head == null){
            throw new IllegalArgumentException("Element does not exist");

        }
        Node newNode = new Node(newData, null);
        Node current = head;
        while(current != null){
            if(current.newData == value){
                current.next = new Node(value, current.next);
                return;
            }
            current = current.next;
        }
        throw new IllegalArgumentException("Element does not exist");

    }

    public Object kthFromEnd(int k){
        if(this.head == null){
            throw new NullPointerException("Linked list is empty");
        }
        int len = 0;

        if(len < k || k < 0){
            throw new IllegalArgumentException("The kth value does not exist");
        }
        Node current = head;
        while(current != null){
            current = current.next;
            len++;
        }
        current = head;
        for(int i = 1; i < len - k; i++){
            current = current.next;
        }
        return current.next.data;
    }

    public static LinkedList mergeList(LinkedList one, LinkedList two){
//       if(one.head == null && two.head == null) {
//           throw new IllegalArgumentException("Both lists are empty");
//       }
//       if(one.head == null){
//           return two;
//       }
//       if(two.head == null){
//           return one;
//       }

       Node firstList = one.head;
       Node secondList = two.head;
       Node firstNext;
       Node secondNext;

       //check to make sure that both lists are not null
        while(firstList != null && secondList != null){
            firstNext = firstList.next;
            secondNext = secondList.next;

            firstList.next = secondList;
            if(firstNext == null){
               firstNext = secondList.next.next;
            } else {
                secondList.next = firstNext;
            }

            firstList = firstNext;
            secondList = secondNext;
        }
        return one;

    }


}
